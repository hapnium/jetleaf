/// Utility class for parsing and formatting stack traces across different platforms.
final class StackTraceParser {
  /// Matches a stacktrace line as generated on Android/iOS devices.
  /// For example: #1 Logger.log (package:logger/src/logger.dart:115:29)
  static final _deviceStackTraceRegex = RegExp(r'#[0-9]+\s+(.+) $$(\S+)$$');

  /// Matches a stacktrace line as generated by Flutter web.
  /// For example: packages/logger/src/printers/pretty_printer.dart 91:37
  static final _webStackTraceRegex = RegExp(r'^((packages|dart-sdk)/\S+/)');

  /// Matches a stacktrace line as generated by browser Dart.
  /// For example: dart:sdk_internal, package:logger/src/logger.dart
  static final _browserStackTraceRegex = RegExp(r'^(?:package:)?(dart:\S+|\S+)');

  /// List of paths to exclude from stack traces
  static const List<String> defaultExcludePaths = [
    'package:jetleaf',
    'dart:',
  ];

  /// Formats a stack trace with the given method count limit.
  /// 
  /// [stackTrace] - The stack trace to format
  /// [methodCount] - Maximum number of methods to include (null for unlimited)
  /// [excludePaths] - Paths to exclude from the stack trace
  /// [stackTraceBeginIndex] - Index to start from in the stack trace
  static String? formatStackTrace(
    StackTrace? stackTrace,
    int? methodCount, {
    List<String> excludePaths = defaultExcludePaths,
    int stackTraceBeginIndex = 0,
  }) {
    if (stackTrace == null) return null;

    List<String> lines = stackTrace
        .toString()
        .split('\n')
        .where((line) =>
            !_discardDeviceStacktraceLine(line, excludePaths) &&
            !_discardWebStacktraceLine(line, excludePaths) &&
            !_discardBrowserStacktraceLine(line, excludePaths) &&
            line.isNotEmpty)
        .toList();

    List<String> formatted = [];
    int stackTraceLength = methodCount != null 
        ? (lines.length < methodCount ? lines.length : methodCount)
        : lines.length;

    for (int count = 0; count < stackTraceLength; count++) {
      var line = lines[count];
      if (count < stackTraceBeginIndex) {
        continue;
      }
      formatted.add('#$count   ${line.replaceFirst(RegExp(r'#\d+\s+'), '')}');
    }

    return formatted.isEmpty ? null : formatted.join('\n');
  }

  /// Extracts the first location from a stack trace for display.
  /// Returns a formatted location string like "main.dart:42:10"
  static String? extractLocation({StackTrace? stackTrace, List<String> excludePaths = defaultExcludePaths}) {
    stackTrace ??= StackTrace.current;

    List<String> lines = stackTrace
        .toString()
        .split('\n')
        .where((line) =>
            !_discardDeviceStacktraceLine(line, excludePaths) &&
            !_discardWebStacktraceLine(line, excludePaths) &&
            !_discardBrowserStacktraceLine(line, excludePaths) &&
            line.isNotEmpty)
        .toList();

    if (lines.isEmpty) return null;

    // Try to extract location from the first relevant line
    var line = lines.first;
    
    // Device format: #1 Logger.log (package:logger/src/logger.dart:115:29)
    var deviceMatch = _deviceStackTraceRegex.firstMatch(line);
    if (deviceMatch != null) {
      var location = deviceMatch.group(2)!;
      return _formatLocation(location);
    }

    // Web format: packages/logger/src/printers/pretty_printer.dart 91:37
    var webMatch = _webStackTraceRegex.firstMatch(line);
    if (webMatch != null) {
      return _formatLocation(line.trim());
    }

    // Browser format: package:logger/src/logger.dart
    var browserMatch = _browserStackTraceRegex.firstMatch(line);
    if (browserMatch != null) {
      return _formatLocation(browserMatch.group(1)!);
    }

    return null;
  }

  /// Formats a location string to be more readable
  static String _formatLocation(String location) {
    // Extract just the filename and line info if it's a full path
    if (location.contains('/')) {
      var parts = location.split('/');
      var filename = parts.last;
      return filename;
    }
    return location;
  }

  static bool _isInExcludePaths(String segment, List<String> excludePaths) {
    for (var element in excludePaths) {
      if (segment.startsWith(element)) {
        return true;
      }
    }
    return false;
  }

  static bool _discardDeviceStacktraceLine(String line, List<String> excludePaths) {
    var match = _deviceStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    final segment = match.group(2)!;
    return _isInExcludePaths(segment, excludePaths);
  }

  static bool _discardWebStacktraceLine(String line, List<String> excludePaths) {
    var match = _webStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    final segment = match.group(1)!;
    return _isInExcludePaths(segment, excludePaths);
  }

  static bool _discardBrowserStacktraceLine(String line, List<String> excludePaths) {
    var match = _browserStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    final segment = match.group(1)!;
    return _isInExcludePaths(segment, excludePaths);
  }
}